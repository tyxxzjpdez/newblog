<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>多核编程 | Tyxxzjpdez&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="现代计算机体系架构一般都是多核的，但是之前学习操作系统上的时候几乎对此完全没有任何介绍。但是最近在学习《Linux环境编程：从应用到内核》，看kernel源码的时候，发现了CPU变量这个概念，我知道CPU变量是单个CPU上的变量，不被其他CPU变量共享，那么为什么需要有单CPU变量呢？它究竟有什么功能呢？带着这个问题，我花了两天时间，逛了一些博客，大概了解了一些多核编程的问题与解决方案，以下就算是">
<meta property="og:type" content="article">
<meta property="og:title" content="多核编程">
<meta property="og:url" content="http://tyxxzjpdez.github.io/newblog/2021/09/09/%E5%A4%9A%E6%A0%B8%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Tyxxzjpdez&#39;s Blog">
<meta property="og:description" content="现代计算机体系架构一般都是多核的，但是之前学习操作系统上的时候几乎对此完全没有任何介绍。但是最近在学习《Linux环境编程：从应用到内核》，看kernel源码的时候，发现了CPU变量这个概念，我知道CPU变量是单个CPU上的变量，不被其他CPU变量共享，那么为什么需要有单CPU变量呢？它究竟有什么功能呢？带着这个问题，我花了两天时间，逛了一些博客，大概了解了一些多核编程的问题与解决方案，以下就算是">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-09-09T21:22:02.000Z">
<meta property="article:modified_time" content="2021-10-08T13:07:49.201Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="SMP">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/newblog/atom.xml" title="Tyxxzjpdez's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/newblog/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/newblog/css/style.css">

  
    
<link rel="stylesheet" href="/newblog/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/newblog/" id="logo">Tyxxzjpdez&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/newblog/">Home</a>
        
          <a class="main-nav-link" href="/newblog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/newblog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://tyxxzjpdez.github.io/newblog"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-多核编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/newblog/2021/09/09/%E5%A4%9A%E6%A0%B8%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-09-09T21:22:02.000Z" itemprop="datePublished">2021-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      多核编程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>现代计算机体系架构一般都是多核的，但是之前学习操作系统上的时候几乎对此完全没有任何介绍。但是最近在学习《Linux环境编程：从应用到内核》，看kernel源码的时候，发现了CPU变量这个概念，我知道CPU变量是单个CPU上的变量，不被其他CPU变量共享，那么为什么需要有单CPU变量呢？它究竟有什么功能呢？带着这个问题，我花了两天时间，逛了一些博客，大概了解了一些多核编程的问题与解决方案，以下就算是做个小的总结。</p>
<h2 id="问题的产生与理论解决">问题的产生与理论解决</h2>
<p>首先我们需要知道的是现代CPU已经无法单纯靠提高主频来增强性能了，早已进入了多核时代。理论上讲，在依赖关系少的任务下，核心增加可以产生立竿见影的效果。但是大多数任务都必然有资源的共享，最典型的就是内存的共享，这就需要多CPU对内存的修改可见（不可见是很容易产生的，因为实际上CPU并不与内存直接交互，它实际上是直接修改CPU的本地cache，对它的写操作如果没有及时写入内存，那对其他CPU就是不可见的了），而要这个问题就是需要先考虑内存一致性的问题，具体内容参看博客<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。我们在这里至少需要以下几点：</p>
<ol>
<li>
<p>最理想的内存模型是顺序一致性模型，它可以做到两点：</p>
<ul>
<li><strong>顺序性：即指令严格地从前往后执行，不做任何的乱序重排</strong>。当然实际上大多数CPU执行都是乱序的，主要有三个方面原因：
<ul>
<li>编译优化。其实不应该归类在这里，因为我们这边一般考虑CPU执行指令阶段。但是考虑到我们一般写的都是C程序，而不是汇编，所以该问题不应该被忽视。</li>
<li>CPU本身的执行优化。为了提升速度，CPU利用自身的性质，将看不出依赖关系的（不同体系架构不一样。为防止出错，我们完全可以认为CPU会胡乱重排。当然，要注意，再胡乱重排至少<strong>保证单CPU上运行一定能保证正确</strong>）指令进行重排提升运行速度。</li>
<li>为了实现一些机制，比如下文会提到的<code>Store Buffer</code>以及<code>Invalid Queue</code>机制（详见这篇博客<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>）而安排的重排。其实可以看做上一点的特例，毕竟这两个机制算是对naive的MESI协议的优化（MESI协议详见这里的论文<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>与博客<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>）。</li>
</ul>
</li>
<li><strong>原子性：每个指令要么不执行，要么就是一口气执行完，没有中间状态</strong>。在这里需要指出一点误区，我曾经以为一个类似<code>MOV</code>那样的指令执行CPU已经保证了它的原子性，但实际上并不是的。只是在单CPU上看不出任何问题，因为任何中断都会在CPU执行完指令（同时如果是乱序执行的，也会保证最后一个指令前的所有指令被执行）以后才会作出相应。因此在单CPU的情况下完全看不出CPU执行一个指令只执行到一半的状态。但是在多核CPU的情况下，问题就完全变了，一个CPU读取一个共享内存的时候完全有可能另一个CPU在对该内存进行写，但还没有完成写入，这时候前一个CPU读取的就是一个非法旧值。实际上这里就从P1（指第一个cpu）先写，然后P2（指第二个cpu）再读变成了：P2先读，P1再写了，也即P2对P1的修改并不可见。其实一般情况下我们无法知道实际上是P1写指令在前，还是P2读指令在前，但是我们应当至少保证一点，那就是任何共享内存的写操作不应当完全并行，而应当立即进行广播告知其他CPU（此时需要对数据总线加锁），从而使得写操作被序列化，使得<strong>可见性</strong>的问题得以解决。</li>
</ul>
</li>
<li>
<p>顺序一致性模型对硬件要求过高，不能实现很好的性能优化。因此，在实际情况下，我们一般对该模型放松一些条件，因此引入了宽松一致性模型。宽松一致性模型的具体实现完全取决于实际架构，具体情况详见上面博客以及wikipedia的memory order词条<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>。我们在这里仅仅讨论x86使用的TSO模型，我们从上面的顺序性与原子性上分别做出约束放宽</p>
<ul>
<li>顺序性（可以理解为单核上的运行顺序）
<ul>
<li>W -&gt; R <strong>支持重排</strong></li>
<li>W -&gt; W 不支持重排</li>
<li>R -&gt; R 不支持重排</li>
<li>R -&gt; W 不支持重排</li>
</ul>
</li>
<li>原子性（可以理解为多核之间的内存可见性）
<ul>
<li><strong>不允许</strong>提前读其他CPU的写，其实就是每个CPU看到其他CPU对<strong>同一个</strong>共享内存的写入的顺序是一致的。如果不理解详见原博客<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>，以及Intel® 64 Architecture Memory Ordering White Paper<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>里提到的<code>Total order on stores to the same location</code>。</li>
<li><strong>允许</strong>两个CPU在分别写入两个<strong>不同</strong>的共享变量时不一致。主要是因为<code>store buffer</code>的优化导致本地读有效，也就是保证单CPU上运行不会出问题，但是此时远程CPU的那个共享内存还没被标记失效就已经运行完了。如果不理解详见Intel® 64 Architecture Memory Ordering White Paper<sup class="footnote-ref"><a href="#fn6" id="fnref6:1">[6:1]</a></sup>里提到的<code>Intra-processor forwarding is allowed</code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>我们看到变成宽松一致性模型固然方便优化，但是一般为了编程方便，我们一般都假定其是顺序一致性的，如果不满足的话，就容易出现各种麻烦。所以我们需要架构有机制可以转为顺序一致性模型。以x86的TSO模型为例，其主要有两个机制：</p>
<ul>
<li>
<p>read-modify-write（RMW）</p>
<p>所谓 RMW，也即 intel 64 架构中的 locked 指令。它只有两个功能，一个是保证本身的原子性，也就是保证本身对所有CPU可见；另一个是该指令上下的指令不可被跨越进行重排。早期是直接锁数据总线，后来转变为cache locking，并结合MESI缓存一致性协议进行一致性的维护。</p>
</li>
<li>
<p>membar，也即内存屏障</p>
<p>博客原文就特意加重<code>globally visible</code>这两个单词。它能够保证屏障前的指令对屏障后的指令<strong>全局可见</strong>。所以理论上只要设置对位置，它可以完美地将宽松一致性模型转变为顺序一致性模型。</p>
</li>
</ul>
</li>
</ol>
<h2 id="实际Linux中的抽象与实现">实际Linux中的抽象与实现</h2>
<h3 id="简介">简介</h3>
<p>该部分具体参看Linux源码下的<code>Documentation/memory-barriers.txt</code><sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>。由于不同硬件实现的内存屏障不一样，Linux主要抽象出的四种屏障：</p>
<ul>
<li>写屏障
<ul>
<li>仅仅保证本CPU的屏障前的写指令一定在屏障后的写指令执行，很直观可理解</li>
</ul>
</li>
<li><strong>数据依赖屏障</strong>
<ul>
<li>最值得注意的屏障，它可以保证<strong>屏障后要访问的地址一定在屏障前完成更新！</strong></li>
</ul>
</li>
<li>读屏障
<ul>
<li>保证本CPU的屏障前的读指令一定在屏障后的读指令执行</li>
<li>同时有<strong>数据依赖屏障</strong>的作用</li>
</ul>
</li>
<li>一般性内存屏障
<ul>
<li>读屏障+写屏障</li>
</ul>
</li>
</ul>
<h3 id="使用">使用</h3>
<p>最典型的例子就是<code>SMP barrier pairing</code>的范式。比如我们要设计实现线程之间的同步。我们看下面这个例子，我们可以认为CPU1在A完成一个工作之后并写入内存以后迅速标记B，这样CPU2在读取B以后通过判断就可以知道A是否已经准备好：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">	CPU 1			CPU 2</span><br><span class="line">	=======================	=======================</span><br><span class="line">		&#123; A = 0, B = 9 &#125;</span><br><span class="line">	STORE A=1</span><br><span class="line">	&lt;write barrier&gt;</span><br><span class="line">	STORE B=2</span><br><span class="line">				LOAD B</span><br><span class="line">				LOAD A</span><br><span class="line"></span><br><span class="line">Without intervention, CPU 2 may then choose to perceive the events on CPU 1 in</span><br><span class="line">some effectively random order, despite the write barrier issued by CPU 1:</span><br><span class="line"></span><br><span class="line">	+-------+       :      :                :       :</span><br><span class="line">	|       |       +------+                +-------+</span><br><span class="line">	|       |------&gt;| A=1  |------      ---&gt;| A-&gt;0  |</span><br><span class="line">	|       |       +------+      \         +-------+</span><br><span class="line">	| CPU 1 |   wwwwwwwwwwwwwwww   \    ---&gt;| B-&gt;9  |</span><br><span class="line">	|       |       +------+        |       +-------+</span><br><span class="line">	|       |------&gt;| B=2  |---     |       :       :</span><br><span class="line">	|       |       +------+   \    |       :       :       +-------+</span><br><span class="line">	+-------+       :      :    \   |       +-------+       |       |</span><br><span class="line">	                             ----------&gt;| B-&gt;2  |------&gt;|       |</span><br><span class="line">	                                |       +-------+       | CPU 2 |</span><br><span class="line">	                                |       | A-&gt;0  |------&gt;|       |</span><br><span class="line">	                                |       +-------+       |       |</span><br><span class="line">	                                |       :       :       +-------+</span><br><span class="line">	                                 \      :       :</span><br><span class="line">	                                  \     +-------+</span><br><span class="line">	                                   ----&gt;| A-&gt;1  |</span><br><span class="line">	                                        +-------+</span><br><span class="line">	                                        :       :</span><br></pre></td></tr></table></figure>
<p>虽然CPU1会保证先执行<code>A=1</code>再执行<code>B=2</code>，但是对于CPU2来说，可能是<code>B</code>先收到invalidate信号，此时虽然最终会保证对<code>A</code>和<code>B</code>的内存修改对所有CPU可见，但是不能保证每个CPU收到信号的顺序相同。因此我们就需要考虑使用读屏障或者数据依赖屏障（当然这里不能考虑数据依赖屏障，因为我们显然希望强制先加载<code>B</code>，再加载A），我们看下面的修改版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">	CPU 1			CPU 2</span><br><span class="line">	=======================	=======================</span><br><span class="line">		&#123; A = 0, B = 9 &#125;</span><br><span class="line">	STORE A=1</span><br><span class="line">	&lt;write barrier&gt;</span><br><span class="line">	STORE B=2</span><br><span class="line">				LOAD B</span><br><span class="line">				&lt;read barrier&gt;</span><br><span class="line">				LOAD A</span><br><span class="line"></span><br><span class="line">then the partial ordering imposed by CPU 1 will be perceived correctly by CPU</span><br><span class="line">2:</span><br><span class="line"></span><br><span class="line">	+-------+       :      :                :       :</span><br><span class="line">	|       |       +------+                +-------+</span><br><span class="line">	|       |------&gt;| A=1  |------      ---&gt;| A-&gt;0  |</span><br><span class="line">	|       |       +------+      \         +-------+</span><br><span class="line">	| CPU 1 |   wwwwwwwwwwwwwwww   \    ---&gt;| B-&gt;9  |</span><br><span class="line">	|       |       +------+        |       +-------+</span><br><span class="line">	|       |------&gt;| B=2  |---     |       :       :</span><br><span class="line">	|       |       +------+   \    |       :       :       +-------+</span><br><span class="line">	+-------+       :      :    \   |       +-------+       |       |</span><br><span class="line">	                             ----------&gt;| B-&gt;2  |------&gt;|       |</span><br><span class="line">	                                |       +-------+       | CPU 2 |</span><br><span class="line">	                                |       :       :       |       |</span><br><span class="line">	                                |       :       :       |       |</span><br><span class="line">	  At this point the read ----&gt;   \  rrrrrrrrrrrrrrrrr   |       |</span><br><span class="line">	  barrier causes all effects      \     +-------+       |       |</span><br><span class="line">	  prior to the storage of B        ----&gt;| A-&gt;1  |------&gt;|       |</span><br><span class="line">	  to be perceptible to CPU 2            +-------+       |       |</span><br><span class="line">	                                        :       :       +-------+</span><br></pre></td></tr></table></figure>
<p>这样一来，由于读屏障的两个效果，我们不仅保证先加载B再加载A，还能保证在加载A之前，保证对A的修改可见（实际实现可能是对该操作维护了一个invalid queue，遇到读屏障就刷新。而相对应的写屏障，一般就是刷新store buffer，详见注脚<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>），所以我们就可以轻松正确实现上面说的功能。</p>
<h2 id="用户空间为什么不需要考虑这些问题">用户空间为什么不需要考虑这些问题</h2>
<h2 id="回归问题">回归问题</h2>
<h2 id="参考">参考</h2>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/maokelong95/article/details/80727952">内存模型系列（上）- 内存一致性模型（Memory Consistency）</a> <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wll1228/article/details/107775976">内存屏障今生之Store Buffer, Invalid Queue</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a target="_blank" rel="noopener" href="http://www.puppetmastertrading.com/images/hwViewForSwHackers.pdf">Memory Barriers: a Hardware View for Software Hackers</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaowenmu1/article/details/89705740">MESI（缓存一致性协议）</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_ordering">memory order</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf">Intel® 64 Architecture Memory Ordering White Paper</a> <a href="#fnref6" class="footnote-backref">↩︎</a> <a href="#fnref6:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.4/source/Documentation/memory-barriers.txt">memory-barriers in linux</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyxxzjpdez.github.io/newblog/2021/09/09/%E5%A4%9A%E6%A0%B8%E7%BC%96%E7%A8%8B/" data-id="ckuidw91f000b1e1f0h14a1c6" data-title="多核编程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/SMP/" rel="tag">SMP</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/newblog/2021/09/19/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Linux的进程调度
        
      </div>
    </a>
  
  
    <a href="/newblog/2021/09/09/gdb%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%8C%87%E4%BB%A4/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">gdb常用调试指令</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/SMP/" rel="tag">SMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/coroutine/" rel="tag">coroutine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/debug/" rel="tag">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/multi-thread/" rel="tag">multi-thread</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/notes/" rel="tag">notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/process/" rel="tag">process</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/roast/" rel="tag">roast</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/shell/" rel="tag">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/thread/" rel="tag">thread</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/newblog/tags/C/" style="font-size: 15px;">C++</a> <a href="/newblog/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/newblog/tags/SMP/" style="font-size: 10px;">SMP</a> <a href="/newblog/tags/coroutine/" style="font-size: 10px;">coroutine</a> <a href="/newblog/tags/debug/" style="font-size: 10px;">debug</a> <a href="/newblog/tags/linux/" style="font-size: 10px;">linux</a> <a href="/newblog/tags/multi-thread/" style="font-size: 15px;">multi-thread</a> <a href="/newblog/tags/notes/" style="font-size: 10px;">notes</a> <a href="/newblog/tags/process/" style="font-size: 10px;">process</a> <a href="/newblog/tags/roast/" style="font-size: 15px;">roast</a> <a href="/newblog/tags/shell/" style="font-size: 10px;">shell</a> <a href="/newblog/tags/thread/" style="font-size: 10px;">thread</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/newblog/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/newblog/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/newblog/archives/2021/08/">August 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/newblog/2021/10/08/pthread%E4%B8%8B%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E8%87%AA%E6%97%8B%E9%94%81/">pthread下互斥锁与自旋锁</a>
          </li>
        
          <li>
            <a href="/newblog/2021/09/19/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/">Linux的进程调度</a>
          </li>
        
          <li>
            <a href="/newblog/2021/09/09/%E5%A4%9A%E6%A0%B8%E7%BC%96%E7%A8%8B/">多核编程</a>
          </li>
        
          <li>
            <a href="/newblog/2021/09/09/gdb%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%8C%87%E4%BB%A4/">gdb常用调试指令</a>
          </li>
        
          <li>
            <a href="/newblog/2021/09/05/%E5%B0%8F%E7%82%B9%E9%9B%86%E9%94%A6/">小点集锦</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/newblog/" class="mobile-nav-link">Home</a>
  
    <a href="/newblog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/newblog/js/jquery-3.4.1.min.js"></script>



  
<script src="/newblog/fancybox/jquery.fancybox.min.js"></script>




<script src="/newblog/js/script.js"></script>





  </div>
</body>
</html>