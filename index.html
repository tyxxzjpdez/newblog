<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Tyxxzjpdez&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Tyxxzjpdez&#39;s Blog">
<meta property="og:url" content="http://tyxxzjpdez.github.io/newblog/index.html">
<meta property="og:site_name" content="Tyxxzjpdez&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/newblog/atom.xml" title="Tyxxzjpdez's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/newblog/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/newblog/css/style.css">

  
    
<link rel="stylesheet" href="/newblog/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/newblog/" id="logo">Tyxxzjpdez&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/newblog/">Home</a>
        
          <a class="main-nav-link" href="/newblog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/newblog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://tyxxzjpdez.github.io/newblog"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-进程调度" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/newblog/2021/09/19/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/" class="article-date">
  <time class="dt-published" datetime="2021-09-19T17:49:17.000Z" itemprop="datePublished">2021-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/newblog/2021/09/19/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/">Linux的进程调度</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文对Linux的进程调度做简单的总结，后续会随着理解的加深不断更新。本文的大部分内容基于《用“芯”探核：基于龙芯的Linux内核探索解析》，内核版本也依据书本为v5.4.x。</p>
<h2 id="简介">简介</h2>
<p>​		调度核心主要负责周期性时钟处理和进程切换，而调度类（目前主要包括实时调度类rt_sched_class，公平调度类fair_sched_class和空闲调度类idle_sched_class）主要负责进程组织和调度策略。其他诸如负载均衡（多处理器系统中用于避免一个处理器过于频繁而另一个处理器过于空闲的机制）、进程迁移等的话题则是调度核心和调度类协同操作的结果。不同的调度类之间具有绝对的优先顺序：实时进程永远优先于普通进程，而普通进程永远优先于空闲进程。</p>
<p>​		本文暂时主要介绍三个调度类，其中重点介绍公平调度类CFS。</p>
<h2 id="调度类">调度类</h2>
<h3 id="公平调度类：CFS策略">公平调度类：CFS策略</h3>
<p>本质上，完全公平算法就是<strong>希望让每个执行单位获得相同的执行时间</strong>。如果我们将优先级考虑进来，就可以这样描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们首先定义调度周期为将所有处于TASK_RUNNING状态的进程都调度一遍的时间，那每个进程实际应当分配的时间片应当满足下面的公式：</span><br><span class="line">                                                   </span><br><span class="line">                                                分配给进程的运行时间 = 调度周期 * 进程权重 / 所有进程权重之和</span><br></pre></td></tr></table></figure>
<p>以上的公式是相当符合直觉的，简单来说其实就是每个进程的时间片大小与进程权重成正比。所以一个很简单的实现方式就是，直接按照上面的方式固定时间片让程序运行给定时间然后被抢占。具体实现可以利用时钟定期触发的中断记录当前进程此次调度执行的时间，并在发现累计超过给定时间片的时候将其睡眠，调入其他进程。这确实是一种简单有效的方式，实际上Linux也大概是在此基础上进行优化的。其中比较值得注意的是下面两个问题：</p>
<ol>
<li>
<p><strong>如何设计进程的权重</strong>？如果是等差数列很容易导致优先级较高的两级之间与优先级较低的两级之间差距悬殊。举个例子，不是一般性，假设相邻优先级之间差1，比如现在有几个等待调度的进程的优先级是100，99，3，2。明明第一二的两个进程和第三四的两个进程都各自优先级只相差1，但是加权比例却很悬殊，也就是100/（100+99+3+2）与99/（100+99+3+2）很接近，但是3/（100+99+3+2）与2/（100+99+3+2）虽然绝对差距一致，但是前者相对比后者却多运行了一半时间。这不符合我们希望的优先级的设定，我们希望优先级n+1的进程比优先级n的进程CPU资源仅相差10%，所以我们显然应当设计为等比数列，所以它应当满足下式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1/(1+1*X) = 45%    =&gt;  X = 55/45 = 1.222</span><br></pre></td></tr></table></figure>
<p>所以综上我们可以权重使得相邻权重成1.222倍比重，实际Linux大概是在1.24到1.25之间。</p>
</li>
<li>
<p>如果确定要抢占，那<strong>应当将执行权交给谁呢</strong>？而且就算当前执行的进程还没用尽时间片，就一定不将它切换出去吗，如果<strong>有其他进程距离希望的时间片长度差距更远该怎么办呢</strong>？为了解决以上的问题，内核给每个进程维护了一个vruntime的变量，它是实际运行时间根据优先级权重归一化之后的虚拟运行时间。对于上面的第一个问题，我们直接选择vruntime最小的进程即可（考虑到进程频繁的创建和终止，所以采用红黑树进行维护）。而对于后面的问题，我们设计一个粒度值，如果当前进程的vruntime仅仅比最小的vruntime多出少于该粒度值的大小，那就不需要重新调度，否则就需要调度。</p>
</li>
</ol>
<h3 id="实时调度类">实时调度类</h3>
<p>为每个优先级维护一个队列。</p>
<p><code>SCHED_RR</code>：实时进程调度策略，时间片轮转，进程用完时间片后加入优先级对应运行队列的尾部，把CPU让给同优先级的其他进程；</p>
<p><code>SCHED_FIFO</code>：实时进程调度策略，先进先出调度没有时间片，没有更高优先级的情况下，只能等待主动让出CPU；</p>
<h3 id="空闲调度类">空闲调度类</h3>
<p>每个CPU都会有一个idle线程，当没有其他进程可以调度时，调度运行idle线程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyxxzjpdez.github.io/newblog/2021/09/19/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/" data-id="cktr5owas000dzzm8gvfj9jlx" data-title="Linux的进程调度" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-多核编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/newblog/2021/09/09/%E5%A4%9A%E6%A0%B8%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-09-09T21:22:02.000Z" itemprop="datePublished">2021-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/newblog/2021/09/09/%E5%A4%9A%E6%A0%B8%E7%BC%96%E7%A8%8B/">多核编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>现代计算机体系架构一般都是多核的，但是之前学习操作系统上的时候几乎对此完全没有任何介绍。但是最近在学习《Linux环境编程：从应用到内核》，看kernel源码的时候，发现了CPU变量这个概念，我知道CPU变量是单个CPU上的变量，不被其他CPU变量共享，那么为什么需要有单CPU变量呢？它究竟有什么功能呢？带着这个问题，我花了两天时间，逛了一些博客，大概了解了一些多核编程的问题与解决方案，以下就算是做个小的总结。</p>
<h2 id="问题的产生与理论解决">问题的产生与理论解决</h2>
<p>首先我们需要知道的是现代CPU已经无法单纯靠提高主频来增强性能了，早已进入了多核时代。理论上讲，在依赖关系少的任务下，核心增加可以产生立竿见影的效果。但是大多数任务都必然有资源的共享，最典型的就是内存的共享，这就需要多CPU对内存的修改可见（不可见是很容易产生的，因为实际上CPU并不与内存直接交互，它实际上是直接修改CPU的本地cache，对它的写操作如果没有及时写入内存，那对其他CPU就是不可见的了），而要这个问题就是需要先考虑内存一致性的问题，具体内容参看博客<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。我们在这里至少需要以下几点：</p>
<ol>
<li>
<p>最理想的内存模型是顺序一致性模型，它可以做到两点：</p>
<ul>
<li><strong>顺序性：即指令严格地从前往后执行，不做任何的乱序重排</strong>。当然实际上大多数CPU执行都是乱序的，主要有三个方面原因：
<ul>
<li>编译优化。其实不应该归类在这里，因为我们这边一般考虑CPU执行指令阶段。但是考虑到我们一般写的都是C程序，而不是汇编，所以该问题不应该被忽视。</li>
<li>CPU本身的执行优化。为了提升速度，CPU利用自身的性质，将看不出依赖关系的（不同体系架构不一样。为防止出错，我们完全可以认为CPU会胡乱重排。当然，要注意，再胡乱重排至少<strong>保证单CPU上运行一定能保证正确</strong>）指令进行重排提升运行速度。</li>
<li>为了实现一些机制，比如下文会提到的<code>Store Buffer</code>以及<code>Invalid Queue</code>机制（详见这篇博客<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>）而安排的重排。其实可以看做上一点的特例，毕竟这两个机制算是对naive的MESI协议的优化（MESI协议详见这里的论文<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>与博客<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>）。</li>
</ul>
</li>
<li><strong>原子性：每个指令要么不执行，要么就是一口气执行完，没有中间状态</strong>。在这里需要指出一点误区，我曾经以为一个类似<code>MOV</code>那样的指令执行CPU已经保证了它的原子性，但实际上并不是的。只是在单CPU上看不出任何问题，因为任何中断都会在CPU执行完指令（同时如果是乱序执行的，也会保证最后一个指令前的所有指令被执行）以后才会作出相应。因此在单CPU的情况下完全看不出CPU执行一个指令只执行到一半的状态。但是在多核CPU的情况下，问题就完全变了，一个CPU读取一个共享内存的时候完全有可能另一个CPU在对该内存进行写，但还没有完成写入，这时候前一个CPU读取的就是一个非法旧值。实际上这里就从P1（指第一个cpu）先写，然后P2（指第二个cpu）再读变成了：P2先读，P1再写了，也即P2对P1的修改并不可见。其实一般情况下我们无法知道实际上是P1写指令在前，还是P2读指令在前，但是我们应当至少保证一点，那就是任何共享内存的写操作不应当完全并行，而应当立即进行广播告知其他CPU（此时需要对数据总线加锁），从而使得写操作被序列化，使得<strong>可见性</strong>的问题得以解决。</li>
</ul>
</li>
<li>
<p>顺序一致性模型对硬件要求过高，不能实现很好的性能优化。因此，在实际情况下，我们一般对该模型放松一些条件，因此引入了宽松一致性模型。宽松一致性模型的具体实现完全取决于实际架构，具体情况详见上面博客以及wikipedia的memory order词条<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>。我们在这里仅仅讨论x86使用的TSO模型，我们从上面的顺序性与原子性上分别做出约束放宽</p>
<ul>
<li>顺序性（可以理解为单核上的运行顺序）
<ul>
<li>W -&gt; R <strong>支持重排</strong></li>
<li>W -&gt; W 不支持重排</li>
<li>R -&gt; R 不支持重排</li>
<li>R -&gt; W 不支持重排</li>
</ul>
</li>
<li>原子性（可以理解为多核之间的内存可见性）
<ul>
<li><strong>不允许</strong>提前读其他CPU的写，其实就是每个CPU看到其他CPU对<strong>同一个</strong>共享内存的写入的顺序是一致的。如果不理解详见原博客<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>，以及Intel® 64 Architecture Memory Ordering White Paper<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>里提到的<code>Total order on stores to the same location</code>。</li>
<li><strong>允许</strong>两个CPU在分别写入两个<strong>不同</strong>的共享变量时不一致。主要是因为<code>store buffer</code>的优化导致本地读有效，也就是保证单CPU上运行不会出问题，但是此时远程CPU的那个共享内存还没被标记失效就已经运行完了。如果不理解详见Intel® 64 Architecture Memory Ordering White Paper<sup class="footnote-ref"><a href="#fn6" id="fnref6:1">[6:1]</a></sup>里提到的<code>Intra-processor forwarding is allowed</code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>我们看到变成宽松一致性模型固然方便优化，但是一般为了编程方便，我们一般都假定其是顺序一致性的，如果不满足的话，就容易出现各种麻烦。所以我们需要架构有机制可以转为顺序一致性模型。以x86的TSO模型为例，其主要有两个机制：</p>
<ul>
<li>
<p>read-modify-write（RMW）</p>
<p>所谓 RMW，也即 intel 64 架构中的 locked 指令。它只有两个功能，一个是保证本身的原子性，也就是保证本身对所有CPU可见；另一个是该指令上下的指令不可被跨越进行重排。早期是直接锁数据总线，后来转变为cache locking，并结合MESI缓存一致性协议进行一致性的维护。</p>
</li>
<li>
<p>membar，也即内存屏障</p>
<p>博客原文就特意加重<code>globally visible</code>这两个单词。它能够保证屏障前的指令对屏障后的指令<strong>全局可见</strong>。所以理论上只要设置对位置，它可以完美地将宽松一致性模型转变为顺序一致性模型。</p>
</li>
</ul>
</li>
</ol>
<h2 id="实际Linux中的抽象与实现">实际Linux中的抽象与实现</h2>
<h3 id="简介">简介</h3>
<p>该部分具体参看Linux源码下的<code>Documentation/memory-barriers.txt</code><sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>。由于不同硬件实现的内存屏障不一样，Linux主要抽象出的四种屏障：</p>
<ul>
<li>写屏障
<ul>
<li>仅仅保证本CPU的屏障前的写指令一定在屏障后的写指令执行，很直观可理解</li>
</ul>
</li>
<li><strong>数据依赖屏障</strong>
<ul>
<li>最值得注意的屏障，它可以保证<strong>屏障后要访问的地址一定在屏障前完成更新！</strong></li>
</ul>
</li>
<li>读屏障
<ul>
<li>保证本CPU的屏障前的读指令一定在屏障后的读指令执行</li>
<li>同时有<strong>数据依赖屏障</strong>的作用</li>
</ul>
</li>
<li>一般性内存屏障
<ul>
<li>读屏障+写屏障</li>
</ul>
</li>
</ul>
<h3 id="使用">使用</h3>
<p>最典型的例子就是<code>SMP barrier pairing</code>的范式。比如我们要设计实现线程之间的同步。我们看下面这个例子，我们可以认为CPU1在A完成一个工作之后并写入内存以后迅速标记B，这样CPU2在读取B以后通过判断就可以知道A是否已经准备好：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">	CPU 1			CPU 2</span><br><span class="line">	=======================	=======================</span><br><span class="line">		&#123; A = 0, B = 9 &#125;</span><br><span class="line">	STORE A=1</span><br><span class="line">	&lt;write barrier&gt;</span><br><span class="line">	STORE B=2</span><br><span class="line">				LOAD B</span><br><span class="line">				LOAD A</span><br><span class="line"></span><br><span class="line">Without intervention, CPU 2 may then choose to perceive the events on CPU 1 in</span><br><span class="line">some effectively random order, despite the write barrier issued by CPU 1:</span><br><span class="line"></span><br><span class="line">	+-------+       :      :                :       :</span><br><span class="line">	|       |       +------+                +-------+</span><br><span class="line">	|       |------&gt;| A=1  |------      ---&gt;| A-&gt;0  |</span><br><span class="line">	|       |       +------+      \         +-------+</span><br><span class="line">	| CPU 1 |   wwwwwwwwwwwwwwww   \    ---&gt;| B-&gt;9  |</span><br><span class="line">	|       |       +------+        |       +-------+</span><br><span class="line">	|       |------&gt;| B=2  |---     |       :       :</span><br><span class="line">	|       |       +------+   \    |       :       :       +-------+</span><br><span class="line">	+-------+       :      :    \   |       +-------+       |       |</span><br><span class="line">	                             ----------&gt;| B-&gt;2  |------&gt;|       |</span><br><span class="line">	                                |       +-------+       | CPU 2 |</span><br><span class="line">	                                |       | A-&gt;0  |------&gt;|       |</span><br><span class="line">	                                |       +-------+       |       |</span><br><span class="line">	                                |       :       :       +-------+</span><br><span class="line">	                                 \      :       :</span><br><span class="line">	                                  \     +-------+</span><br><span class="line">	                                   ----&gt;| A-&gt;1  |</span><br><span class="line">	                                        +-------+</span><br><span class="line">	                                        :       :</span><br></pre></td></tr></table></figure>
<p>虽然CPU1会保证先执行<code>A=1</code>再执行<code>B=2</code>，但是对于CPU2来说，可能是<code>B</code>先收到invalidate信号，此时虽然最终会保证对<code>A</code>和<code>B</code>的内存修改对所有CPU可见，但是不能保证每个CPU收到信号的顺序相同。因此我们就需要考虑使用读屏障或者数据依赖屏障（当然这里不能考虑数据依赖屏障，因为我们显然希望强制先加载<code>B</code>，再加载A），我们看下面的修改版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">	CPU 1			CPU 2</span><br><span class="line">	=======================	=======================</span><br><span class="line">		&#123; A = 0, B = 9 &#125;</span><br><span class="line">	STORE A=1</span><br><span class="line">	&lt;write barrier&gt;</span><br><span class="line">	STORE B=2</span><br><span class="line">				LOAD B</span><br><span class="line">				&lt;read barrier&gt;</span><br><span class="line">				LOAD A</span><br><span class="line"></span><br><span class="line">then the partial ordering imposed by CPU 1 will be perceived correctly by CPU</span><br><span class="line">2:</span><br><span class="line"></span><br><span class="line">	+-------+       :      :                :       :</span><br><span class="line">	|       |       +------+                +-------+</span><br><span class="line">	|       |------&gt;| A=1  |------      ---&gt;| A-&gt;0  |</span><br><span class="line">	|       |       +------+      \         +-------+</span><br><span class="line">	| CPU 1 |   wwwwwwwwwwwwwwww   \    ---&gt;| B-&gt;9  |</span><br><span class="line">	|       |       +------+        |       +-------+</span><br><span class="line">	|       |------&gt;| B=2  |---     |       :       :</span><br><span class="line">	|       |       +------+   \    |       :       :       +-------+</span><br><span class="line">	+-------+       :      :    \   |       +-------+       |       |</span><br><span class="line">	                             ----------&gt;| B-&gt;2  |------&gt;|       |</span><br><span class="line">	                                |       +-------+       | CPU 2 |</span><br><span class="line">	                                |       :       :       |       |</span><br><span class="line">	                                |       :       :       |       |</span><br><span class="line">	  At this point the read ----&gt;   \  rrrrrrrrrrrrrrrrr   |       |</span><br><span class="line">	  barrier causes all effects      \     +-------+       |       |</span><br><span class="line">	  prior to the storage of B        ----&gt;| A-&gt;1  |------&gt;|       |</span><br><span class="line">	  to be perceptible to CPU 2            +-------+       |       |</span><br><span class="line">	                                        :       :       +-------+</span><br></pre></td></tr></table></figure>
<p>这样一来，由于读屏障的两个效果，我们不仅保证先加载B再加载A，还能保证在加载A之前，保证对A的修改可见（实际实现可能是对该操作维护了一个invalid queue，遇到读屏障就刷新。而相对应的写屏障，一般就是刷新store buffer，详见注脚<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>），所以我们就可以轻松正确实现上面说的功能。</p>
<h2 id="用户空间为什么不需要考虑这些问题">用户空间为什么不需要考虑这些问题</h2>
<h2 id="回归问题">回归问题</h2>
<h2 id="参考">参考</h2>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/maokelong95/article/details/80727952">内存模型系列（上）- 内存一致性模型（Memory Consistency）</a> <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wll1228/article/details/107775976">内存屏障今生之Store Buffer, Invalid Queue</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a target="_blank" rel="noopener" href="http://www.puppetmastertrading.com/images/hwViewForSwHackers.pdf">Memory Barriers: a Hardware View for Software Hackers</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaowenmu1/article/details/89705740">MESI（缓存一致性协议）</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_ordering">memory order</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf">Intel® 64 Architecture Memory Ordering White Paper</a> <a href="#fnref6" class="footnote-backref">↩︎</a> <a href="#fnref6:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.4/source/Documentation/memory-barriers.txt">memory-barriers in linux</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyxxzjpdez.github.io/newblog/2021/09/09/%E5%A4%9A%E6%A0%B8%E7%BC%96%E7%A8%8B/" data-id="cktr5owap000azzm84xnv73b8" data-title="多核编程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/SMP/" rel="tag">SMP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-gdb常用调试指令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/newblog/2021/09/09/gdb%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%8C%87%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2021-09-09T14:43:01.000Z" itemprop="datePublished">2021-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/newblog/2021/09/09/gdb%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%8C%87%E4%BB%A4/">gdb常用调试指令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="背景">背景</h2>
<p>最近在看《Linux环境编程：从应用到内核》，涉及到了比较多的内核代码，恰好之前尝试过调试内核，但那时由于对内核无从下手，很容易一进门就迷失，进而就失去兴趣了。这次打算以这本书作为一个线索，不过多地追究细节，快速定位并搞懂关键性概念。</p>
<p>如何创建调试环境虽然比较麻烦，但网上教程较多，这里不多赘述，具体可参看以下三篇博客：</p>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/CtripDBA/p/12290071.html">使用 linux kernel +busybox 定制linux系统</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://consen.github.io/2018/01/17/debug-linux-kernel-with-qemu-and-gdb/">使用QEMU和GDB调试Linux内核</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaojia92/article/details/100717580">搭建Linux kernel调试环境-busybox构建最小根文件系统</a></p>
</li>
</ul>
<p>本文重点是搭建调试环境以后如何使用gdb进行调试</p>
<h2 id="gdb配置">gdb配置</h2>
<p>虽然现在随着gdb版本的提高，功能也越来越完善，但是经过配置完全可以变得更友好得多，这里主要使用<a target="_blank" rel="noopener" href="https://github.com/pwndbg/pwndbg">pwndbg</a> 这个工具。当然，在内核调试该工具相应比较慢，甚至出现半天不响应的情况，所以可能存在bug，但是在一般的项目中是足够的，曾经就使用它查看过动态库的载入，默认配置就已经很舒服，很直观。</p>
<h2 id="gdb命令">gdb命令</h2>
<h3 id="建议的额外编译选项">建议的额外编译选项</h3>
<p>编译建议加上<code>-ggdb</code>，从<code>man gdb</code>可以看到这对于gdb可以产生几乎最多的调试信息</p>
<h3 id="开始调试">开始调试</h3>
<ul>
<li><code>gdb program</code> 一般指从没有运行的程序开始调试</li>
<li><code>gdb program core</code> 指定可执行文件和core文件</li>
<li><code>gdb program 123</code>或者<code>gdb -p 1234</code>指定调试一个已经运行的程序，此时一般需要调试的程序与被调试的程序之间是祖先与子孙关系，否则就需要root权限</li>
</ul>
<h3 id="常用命令">常用命令</h3>
<ul>
<li><strong>help cmd</strong>         #查看相关命令的使用方法</li>
<li><strong>start</strong>                  #开始调试，并停在第一行代码</li>
<li><strong>list</strong>                     #查看当前位置上下的源代码</li>
<li><strong>breakpoints  &lt;lines&gt;/&lt;func&gt;</strong>        #在制定行或者函数设置断点</li>
<li><strong>info breakpoints</strong>                             #查看当前设置的断点</li>
<li><strong>delete breakpoints [NO]</strong>               #删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增</li>
<li><strong>step</strong>                  #执行一行源程序代码，如果此行代码中有函数调用，则进入该函数</li>
<li><strong>next</strong>                  #执行一行源程序代码，此行代码中的函数调用也一并直接执行，不跳入</li>
<li><strong>run</strong>                   #运行被调试的程序。如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处</li>
<li><strong>continue</strong>         #继续执行被调试程序，直至下一个断点或程序结束</li>
<li><strong>finish</strong>               #函数结束</li>
<li><strong>backtrace</strong>       #查看当前栈帧</li>
<li><strong>layout asm/next</strong>                               #使用asm或者next布局，比较友好，详情看help</li>
<li><strong>print/display/disassemble 未完待续</strong></li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/mercy_ps/article/details/81542986">GDB调试基本命令</a></li>
<li><code>man gdb</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyxxzjpdez.github.io/newblog/2021/09/09/gdb%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%8C%87%E4%BB%A4/" data-id="cktr5owak0003zzm827l8hrwt" data-title="gdb常用调试指令" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/debug/" rel="tag">debug</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-小点集锦" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/newblog/2021/09/05/%E5%B0%8F%E7%82%B9%E9%9B%86%E9%94%A6/" class="article-date">
  <time class="dt-published" datetime="2021-09-05T21:10:28.000Z" itemprop="datePublished">2021-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/newblog/2021/09/05/%E5%B0%8F%E7%82%B9%E9%9B%86%E9%94%A6/">小点集锦</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>主要记录一些有点意思但又没有必要为此写新博客的一些点</p>
<ol>
<li>
<p>迭代器的失效一般与容器类型相关，详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fnlingnzb-learner/p/9300073.html">C++迭代器失效的几种情况总结</a>。但是具体实现可能会有区别，例如vector的erase为了减小开销就使用拷贝然后销毁末尾的元素，这样的erase其实并不会让删除元素后面的所有迭代器失效，详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chaohacker/p/13024357.html">c++之你真的了解vector的erase吗</a></p>
</li>
<li>
<p><code>gcc</code>编译链接的时候使用<code>-v</code>参数，可以显示具体的详细过程。我们可以发现最后一步并没有直接使用<code>ld</code>，而是使用了<code>collect2</code>，它主要是为了实现main函数开始前以及结束后的一些函数的注册。详见<a target="_blank" rel="noopener" href="http://www.wanglianghome.org/2011/04/14/collect2/">collect2</a>以及<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gccint/Collect2.html">官方文档</a>，也可以使用<code>info gccint-11 'collect2'</code>查看离线的官方文档。</p>
</li>
<li>
<p>数据库加间隙锁的本质是因为当本条满足条件，那最多它的相邻的两个区间也会满足条件，当这些所有间隙都被锁了以后，才不会出现幻读，因为要满足之前条件的insert必然在上面的所有间隙内。（当然以上是在查询为索引的情况下）</p>
</li>
<li>
<p>逻辑上不要认为因为需要epoll的边沿触发所以才将打开文件属性设置为非阻塞。而应当反过来，考虑到IO的复杂性，我们希望在epoll的线程中<strong>为了公平要保持忙碌</strong>，不要陷入某个IO阻塞使得其他IO饥饿，所以我们要设计一个非阻塞的多路复用模型（本质上其实也就是使得事件响应机制<strong>变得更加细粒度化</strong>）。一般非阻塞我们都会读到出现EAGAIN错误为止，而这相当于修改了打开文件的状态。所以我们希望epoll不要对IO的所有状态都返回事件，而应当仅仅在打开文件的状态由不可用到可用才返回事件。也即边沿触发是对多路IO复用的非阻塞版本的额外支持。</p>
</li>
<li>
<p>可以在构造函数的<strong>初始化列表里强制类成员的初始化顺序</strong>，使得含有依赖的初始化能够顺利完成。</p>
</li>
<li>
<p>进程上下文与中断上下文的区别</p>
<ul>
<li>
<p>进程上下文：用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。具体可以分为：</p>
<ul>
<li>用户级上下文: 正文、数据、用户堆栈以及共享存储区；</li>
<li>寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；</li>
<li>系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。</li>
</ul>
<p>切换进程上下文需要切换以上所有上下文。但是系统调用会陷入到内核，仅进行寄存器上下文的切换，此时内核代表用户在内核态执行，也就是说<strong>此时陷入内核执行的代码绑定了一个存在用户空间的进程</strong>。</p>
</li>
<li>
<p>中断上下文：硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。<strong>完全是硬件与内核的交互，无需绑定一个存在用户空间的进程。同时也因为机制简单，无法再被切换出，因此禁止睡眠。</strong></p>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyxxzjpdez.github.io/newblog/2021/09/05/%E5%B0%8F%E7%82%B9%E9%9B%86%E9%94%A6/" data-id="cktr5owaq000bzzm83j16314n" data-title="小点集锦" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/notes/" rel="tag">notes</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-linux-shell-常用命令集锦" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/newblog/2021/08/31/linux-shell-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6/" class="article-date">
  <time class="dt-published" datetime="2021-08-31T13:50:48.000Z" itemprop="datePublished">2021-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/newblog/2021/08/31/linux-shell-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6/">Linux shell 常用命令集锦</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="常用指令">常用指令</h2>
<h3 id="sort">sort</h3>
<p><code>sort [OPTION]... [FILE]...</code></p>
<p>对输入进行<strong>排序</strong></p>
<p>常用的参数:</p>
<ul>
<li><code>-n</code> 使用数值进行排序</li>
<li><code>-u</code> 去重，相同的情况仅仅输出第一个</li>
<li><code>-r</code> 从大到小排序</li>
<li><code>-k</code> 指定一个特定的key进行排序，而不是整一行
<ul>
<li>比如想要使用空格作为分隔符，然后第二个作为数字键，那就使用<code>sort -k 2n</code></li>
<li>如果要指定指定其他分隔符 ，可以使用-t参数，例如使用冒号作为分隔符，<code>sort -t: -k 3n /etc/passwd</code></li>
</ul>
</li>
</ul>
<h3 id="awk">awk</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">BEGIN &#123; actions &#125; </span></span><br><span class="line"><span class="string">/pattern/ &#123; actions &#125;</span></span><br><span class="line"><span class="string">/pattern/ &#123; actions &#125;</span></span><br><span class="line"><span class="string">……….</span></span><br><span class="line"><span class="string">END &#123; actions &#125; </span></span><br><span class="line"><span class="string">&#x27;</span> filenames  </span><br></pre></td></tr></table></figure>
<p>BEGIN表示在所有匹配前先做一些事情，END表示在所有匹配结束后再做一些事情</p>
<p>例如有下面的文件a.txt，像求出水果的平均价格，可以这么写<code>awk '/apple/&#123;cnt+=1;sum+=$2&#125;END&#123;print sum/cnt&#125; a.txt' </code></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apple 3.5</span><br><span class="line">peach 4.6</span><br><span class="line">apple 4.7</span><br><span class="line">pear 5.3</span><br></pre></td></tr></table></figure>
<p>要点：</p>
<ul>
<li>
<p>如果需要改变分割符，可以使用<code>-F</code>参数，举例：<code>awk -F ',' '&#123;print $NF&#125;' filename</code></p>
</li>
<li>
<p>awk内有特殊变量，常见的有</p>
<table>
<thead>
<tr>
<th>特殊变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>$number</td>
<td>表示记录的字段。比如，$1表示第1个字段，$2表示第2个字段，如此类推。而$0比较特殊，表示整个当前行</td>
</tr>
<tr>
<td>FS</td>
<td>表示字段分隔符</td>
</tr>
<tr>
<td>NF</td>
<td>表示当前记录中的字段数量</td>
</tr>
<tr>
<td>NR</td>
<td>表示当前记录的编号（awk将第一个记录算作记录号1）</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="uniq">uniq</h3>
<p>一般与sort一起使用，常用以下参数</p>
<ul>
<li>-c 对排序后的数据进行计数</li>
<li>-d 对排序后的数据只统计重复过的数据</li>
<li>-u 对排序后的数据去重</li>
</ul>
<h3 id="xargs">xargs</h3>
<p><code>xargs [options] [command [initial-arguments]]</code></p>
<p>对标准输入的数据进行处理后作为参数给command，如果没有command就直接将参数输出到标准输出流</p>
<p>常用参数：</p>
<ul>
<li>-n max-args 设置执行命令的最大参数个数</li>
</ul>
<h3 id="head">head</h3>
<p>取文件头10行</p>
<ul>
<li>
<p>-n [-]NUM</p>
<p>取前NUM行，有-就表明输出开头到最后倒数第NUM行</p>
</li>
</ul>
<h3 id="tail">tail</h3>
<p>取文件尾10行</p>
<ul>
<li>
<p>-n [+]NUM</p>
<p>取后NUM行，有+就表明从第NUM开始输出到最后</p>
</li>
</ul>
<h2 id="经典问题与解答">经典问题与解答</h2>
<ol>
<li>
<p>对输入文件里面的所有单词进行统计个数，并且按照单词个数从大到小进行输出</p>
<ul>
<li>
<p>第一种</p>
<p><code>cat words.txt | xargs -n 1 | sort | uniq -c | sort -nr | awk '&#123;print $2&quot; &quot;$1&#125;'</code></p>
</li>
<li>
<p>第二种</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    for(i = 1; i &lt;= NF; i++)&#123;</span></span><br><span class="line"><span class="string">        res[$i] += 1</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">END&#123;</span></span><br><span class="line"><span class="string">    for(k in res)&#123;</span></span><br><span class="line"><span class="string">        print k&quot; &quot;res[k]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> words.txt | sort -nr -k2</span><br></pre></td></tr></table></figure>
<p>注意到awk内置有执行控制语句，以及数组类型，字符串可以作为key</p>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyxxzjpdez.github.io/newblog/2021/08/31/linux-shell-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6/" data-id="cktr5owal0004zzm84gbyhgom" data-title="Linux shell 常用命令集锦" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/shell/" rel="tag">shell</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Linux下的进程、进程与协程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/newblog/2021/08/29/Linux%E4%B8%8B%E7%9A%84%E8%BF%9B%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-08-29T20:04:28.000Z" itemprop="datePublished">2021-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/newblog/2021/08/29/Linux%E4%B8%8B%E7%9A%84%E8%BF%9B%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/">结合源码从开销角度看Linux下的进程、进程与协程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="问题">问题</h2>
<p>最近面试的时候被问了两个问题：</p>
<ul>
<li>进程、线程、协程的关系与区别</li>
<li>为什么要使用线程池，相比普通的方式有什么优势？</li>
</ul>
<p>两个问题其实不算很难回答，我主要从开销角度讲的。但是面试官随后便问了我到底是什么开销呢？我一下就懵了。乖乖，这不看过源码谁知道，所以就有了这篇博客。</p>
<h2 id="分析">分析</h2>
<h3 id="进程与线程">进程与线程</h3>
<p><strong>本文的内容主要基于《用“芯”探核：基于龙芯的Linux内核探索解析》以及一点点《CSAPP》的内容。</strong></p>
<p>在Linux下新建一个进程或者线程都会调用<code>fork</code>族的系统调用，也就是<code>fork</code>,<code>vfork</code>,<code>clone</code>。他们最终都是在<code>_do_fork(struct kernel_clone_args*)</code>函数内最终具体实现 。该函数的参数比较复杂，其具体指定了不同的创建方式。这里仅仅列举以下几个：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CLONE_VM</code></td>
<td>子进程共享父进程的<strong>地址空间和各级页表</strong></td>
</tr>
<tr>
<td><code>CLONE_FS</code></td>
<td>子进程共享父进程的文件系统上下文</td>
</tr>
<tr>
<td><code>CLONE_FILES</code></td>
<td>子进程共享父进程的打开的文件描述符表</td>
</tr>
<tr>
<td><code>CLONE_SIGHAND</code></td>
<td>子进程共享父进程的信号处理函数表</td>
</tr>
<tr>
<td><code>CLONE_VFORK</code></td>
<td>子进程执行新程序或退出之前父进程阻塞</td>
</tr>
<tr>
<td><code>CLONE_THREAD</code></td>
<td>将子进程<strong>插入父进程所在的线程组</strong></td>
</tr>
<tr>
<td><code>CLONE_SETTLS</code></td>
<td>子进程将创建自己的线程本地存储</td>
</tr>
</tbody>
</table>
<p>而这三个系统调用大概是使用了其中几个标志</p>
<ul>
<li><code>fork</code>函数没有特殊标志</li>
<li><code> vfork</code>则有<code>CLONE_VFORK</code>和<code>CLONE_VM</code>标志</li>
<li><code>clone</code>一般用作创建线程。我们知道一般情况下<code>std::thread</code>创建线程的方式是依赖于pthread动态链接库的（ 源码上赫然写着<code>pthread_create</code>，而且使用命令行编译链接，不加上-lpthread也会链接错）。而它的底层实现使用了如下标志<code>CLONE_VM</code>、<code>CLONE_FS</code>、<code>CLONE_FILES</code>、<code>CLONE_SIGNAL</code>、<code>CLONE_SETTLS</code>、<code>CLONE_PARENT_SETTID</code>、<code>CLONE_CHILD_CLEARTID</code>、<code>CLONE_SYSVSEM</code>。所以Pthread库创建出来的线程<strong>共享父进程的地址空间、文件系统上下文、文件描述符、信号及其处理函数、SysVIPC信号量取消队列</strong>，和父进程处于同一线程组，创建自己的线程本地存储，将子进程的PID返回给调用者的<code>parent_tidptr</code>字段，并在执行新程序或退出时清空<code>child_tidptr</code>字段同时唤醒等待该事件的进程。</li>
</ul>
<p>其实从这里我们便可见一斑了。线程比进程的创建多了很多标志，而且这些标志大多是声明自己与父进程共享一些资源。也就是说从开销来说，相比一般的进程，线程就是共享代替创建，所以就少了很多新建与维护代价。我们以<code>CLONE_VM</code>这个标志为例简单地过一遍代码（内核版本5.2）：</p>
<p>首先是<code>_do_fork</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> _do_fork(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span><br><span class="line">	      <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span><br><span class="line">	      <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span><br><span class="line">	      <span class="keyword">int</span> __user *parent_tidptr,</span><br><span class="line">	      <span class="keyword">int</span> __user *child_tidptr,</span><br><span class="line">	      <span class="keyword">unsigned</span> <span class="keyword">long</span> tls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">p = <span class="built_in">copy_process</span>(clone_flags, stack_start, stack_size, parent_tidptr,</span><br><span class="line">			 child_tidptr, <span class="literal">NULL</span>, trace, tls, NUMA_NO_NODE);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	pid = <span class="built_in">get_task_pid</span>(p, PIDTYPE_PID);</span><br><span class="line">	nr = <span class="built_in">pid_vnr</span>(pid);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>copy_process负责对进程数据结构<code>task_struct</code>根据标志进行拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __latent_entropy struct task_struct *<span class="title">copy_process</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">int</span> __user *parent_tidptr,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">int</span> __user *child_tidptr,</span></span></span><br><span class="line"><span class="params"><span class="function">					struct pid *pid,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">int</span> trace,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">unsigned</span> <span class="keyword">long</span> tls,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 拷贝现有task_struct，返回局部变量p</span></span><br><span class="line">    p = <span class="built_in">dup_task_struct</span>(current, node);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    retval = <span class="built_in">copy_semundo</span>(clone_flags, p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_security;</span><br><span class="line">	retval = <span class="built_in">copy_files</span>(clone_flags, p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_semundo;</span><br><span class="line">	retval = <span class="built_in">copy_fs</span>(clone_flags, p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_files;</span><br><span class="line">	retval = <span class="built_in">copy_sighand</span>(clone_flags, p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line">	retval = <span class="built_in">copy_signal</span>(clone_flags, p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_sighand;</span><br><span class="line">	retval = <span class="built_in">copy_mm</span>(clone_flags, p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_signal;</span><br><span class="line">	retval = <span class="built_in">copy_namespaces</span>(clone_flags, p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_mm;</span><br><span class="line">	retval = <span class="built_in">copy_io</span>(clone_flags, p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_namespaces;</span><br><span class="line">	retval = <span class="built_in">copy_thread_tls</span>(clone_flags, stack_start, stack_size, p, tls);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_io;</span><br><span class="line">    <span class="comment">//..</span></span><br></pre></td></tr></table></figure>
<p>接下来进入<code>copy_mm</code>，看标志位究竟如何影响拷贝</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_mm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    oldmm = current-&gt;mm;</span><br><span class="line">	<span class="keyword">if</span> (!oldmm)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">		<span class="built_in">mmget</span>(oldmm);</span><br><span class="line">		mm = oldmm;</span><br><span class="line">		<span class="keyword">goto</span> good_mm;</span><br><span class="line">	&#125;</span><br><span class="line">	retval = -ENOMEM;</span><br><span class="line">	mm = <span class="built_in">dup_mm</span>(tsk, current-&gt;mm);</span><br><span class="line">	<span class="keyword">if</span> (!mm)</span><br><span class="line">		<span class="keyword">goto</span> fail_nomem;</span><br><span class="line">good_mm:</span><br><span class="line">	tsk-&gt;mm = mm;</span><br><span class="line">	tsk-&gt;active_mm = mm;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail_nomem:</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br></pre></td></tr></table></figure>
<p>这里就已经很能说明问题了，如果有了<code>CLONE_VM</code>标志就直接指向相同的指针，代价仅为一次赋值而已，但是如果没有这个标志的话，就要调用<code>dup_mm</code>了，即使在COW（写时复制）的情况下，可以不复制内存页面mmap，但是至少也必须得复制页表，否则压根没有办法实现写时复制了嘛。</p>
<h3 id="线程与协程">线程与协程</h3>
<p>看过一个简单的<a target="_blank" rel="noopener" href="https://github.com/cloudwu/coroutine">协程实现</a>。简单来说就是实现了一个拥有单个长时存在的共享栈和若干个动态大小的私密栈，并且使用<code>getcontext, setcontext</code>等函数进行上下文的切换的这么一个协程。由于调度器是用户设计的，所以切换自由，甚至可以设计实现一个yield函数，以进行主动的切换。</p>
<p>它的创建和切换代价极小，我们可以从<code>getcontext, setcontext</code>这些函数维护的<code>ucontext_t</code>数据结构就可以看出来，可以使用<code>man getcontext</code>可以查看该数据结构的成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> &#123;</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">               <span class="keyword">sigset_t</span>          uc_sigmask;</span><br><span class="line">               <span class="keyword">stack_t</span>           uc_stack;</span><br><span class="line">               <span class="keyword">mcontext_t</span>        uc_mcontext;</span><br><span class="line">               ...</span><br><span class="line">           &#125; <span class="keyword">ucontext_t</span>;</span><br></pre></td></tr></table></figure>
<p><code>mcontext_t</code>这一类型与具体硬件实现有关，可以认为是切换执行流的最小开销。而此外，<code>uc_link</code>一般与<code>makecontext</code>有关，指的是当前执行流终止之后切换的上下文的指针。<code>uc_stack</code>维护栈信息，一般主要维护栈顶和栈大小即可。最后是<code>uc_sigmask</code>，它是一个信号的掩码，表示屏蔽信号集合。所以综上，除了与机器相关的寄存器维护代价以及信号掩码的维护代价（信号掩码的数据结构较大，在我的机器上大概有128字节）以外，仅仅只有几个字节的拷贝代价，不需要陷入内核，没有任何内核维护状态的代价，因此不管是创建还是切换都是超轻量。</p>
<p>因此协程的最大的优点是需要维护的状态少，因此切换代价小。所以应当直接适用于高并发。一旦有了它，就不再需要考虑不同请求对多线程的复用（当然还是需要有这部分代码的，但是例如go语言可以直接被封装好，一个语句就可以创建协程）所以也因此降低了编程难度。</p>
<h3 id="总结">总结</h3>
<p>所以，简单来说，为了更好地使用多处理器以实现真正的并行，同时考虑到这时一般多个执行流应该是相互协作的，因此可以设计为某些资源共享，因此有了线程。然后由于某些业务需求，需要支持高并发，这时线程的创建以及切换代价就成为了瓶颈。这时更加轻量级的协程便应运而生。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyxxzjpdez.github.io/newblog/2021/08/29/Linux%E4%B8%8B%E7%9A%84%E8%BF%9B%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/" data-id="cktr5owad0000zzm82arg419w" data-title="结合源码从开销角度看Linux下的进程、进程与协程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/coroutine/" rel="tag">coroutine</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/process/" rel="tag">process</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/thread/" rel="tag">thread</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-to-do-list" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/newblog/2021/08/28/to-do-list/" class="article-date">
  <time class="dt-published" datetime="2021-08-28T22:06:00.000Z" itemprop="datePublished">2021-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/newblog/2021/08/28/to-do-list/">计划表</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="总计划">总计划</h2>
<ol>
<li>《C++ primer》阅读计划，目前考虑阅读模板与tuple</li>
<li>面试相关，根据面试官的问题去搞懂一些比较深的东西</li>
<li>源码阅读，以后端组件为主。目前可以从nginx开始</li>
<li>有趣的书籍，可以开始陈硕的《Linux多线程服务端编程》以及《C++ 并发实战》</li>
<li>上手小项目，考虑目前从简单开始实现一个消息队列</li>
</ol>
<h2 id="每周计划">每周计划</h2>
<p>待完善…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyxxzjpdez.github.io/newblog/2021/08/28/to-do-list/" data-id="cktr5owao0008zzm81ngg75f8" data-title="计划表" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/roast/" rel="tag">roast</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Problem-about-std-thread" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/newblog/2021/08/28/Problem-about-std-thread/" class="article-date">
  <time class="dt-published" datetime="2021-08-28T19:19:44.000Z" itemprop="datePublished">2021-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/newblog/2021/08/28/Problem-about-std-thread/">关于std::thread初始化的一点问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="问题代码">问题代码</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="built_in">Message</span>(<span class="keyword">const</span> std::string&amp;s = <span class="string">&quot;&quot;</span>):<span class="built_in">s</span>(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span>&#123;</span></span><br><span class="line">    std::queue&lt;Message&gt; qu;</span><br><span class="line">    std::mutex mutex;</span><br><span class="line">    std::condition_variable condition;</span><br><span class="line">    <span class="keyword">size_t</span> cap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MessageQueue</span>(<span class="keyword">size_t</span> cap=<span class="number">100</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">(Message message)</span></span>;</span><br><span class="line">    <span class="function">Message <span class="title">consume</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MessageQueue mq;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">(MessageQueue mq)</span></span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Message <span class="title">consume</span><span class="params">(MessageQueue mq)</span></span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t1 = std::<span class="built_in">thread</span>(produce, mq);</span><br><span class="line">    <span class="keyword">auto</span> t2 = std::<span class="built_in">thread</span>(consume, mq);</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错误信息">错误信息</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/c++/<span class="number">8</span>/thread:<span class="number">120</span>:<span class="number">17</span>: error: <span class="keyword">static</span> assertion failed: </span><br><span class="line">std::thread arguments must be invocable after conversion to rvalues</span><br></pre></td></tr></table></figure>
<h2 id="问题分析">问题分析</h2>
<p>首先定位<code>/usr/include/c++/8/thread</code>第120行左右</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Callable, <span class="keyword">typename</span>... _Args,</span><br><span class="line">     <span class="keyword">typename</span> = _Require&lt;__not_same&lt;_Callable&gt;&gt;&gt;</span><br><span class="line">     <span class="keyword">explicit</span></span><br><span class="line">     <span class="built_in">thread</span>(_Callable&amp;&amp; __f, _Args&amp;&amp;... __args)</span><br><span class="line">     &#123;</span><br><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>( __is_invocable&lt;<span class="keyword">typename</span> decay&lt;_Callable&gt;::type,</span><br><span class="line">			      <span class="keyword">typename</span> decay&lt;_Args&gt;::type...&gt;::value,</span><br><span class="line">  <span class="string">&quot;std::thread arguments must be invocable after conversion to rvalues&quot;</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p>decay有很多功能。在这里可以认为将函数引用转为函数指针，将参数的引用类型去掉引用（也就是这里英文说的转为右值）。而<code>__is_invocable</code>是判断转换之后的类型是否适配，是否可以使用对应的实参完成到形参的转换。我们发现这里转换以后的形参和实参都是<code>MessageQueue</code>，看上去似乎没有问题。但是实际上问题恰好就在这里，因为形参不是引用类型，不管实参是什么类型，都会需要<strong>调用相应的拷贝构造函数</strong>。而由于<code>MessageQueue</code>里有成员<code>std::mutex</code>和<code>std::condition_variable</code>，其拷贝构造函数都被<code>delete</code>，所以<code>MessageQueue</code>的默认的拷贝构造函数无法被调用，因而断言失败。</p>
<h2 id="解决方案">解决方案</h2>
<h3 id="解决问题">解决问题</h3>
<p>实际上，从设计上讲，本来就完全不应当让<code>MessageQueue</code>调用拷贝构造函数，完全是多余的开销。所以不妨进行像下面这样的修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue mq;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">(MessageQueue&amp; mq)</span></span>;</span><br><span class="line"><span class="function">Message <span class="title">consume</span><span class="params">(MessageQueue&amp; mq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t1 = std::<span class="built_in">thread</span>(produce, std::<span class="built_in">ref</span>(mq));</span><br><span class="line">    <span class="keyword">auto</span> t2 = std::<span class="built_in">thread</span>(consume, std::<span class="built_in">ref</span>(mq));</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先显然是直接将<code>produce</code>和<code>consume</code>的形参改为引用。但仅仅这样的修改是无法通过<code> __is_invocable</code>的判断的。因为左值引用无法绑定右值。所以需要使用<code>std::ref</code>来做一个修饰，我们可以看源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> reference_wrapper&lt;_Tp&gt;</span></span><br><span class="line"><span class="function">    <span class="title">ref</span><span class="params">(_Tp&amp; <span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> reference_wrapper&lt;_Tp&gt;(<span class="keyword">__t</span>); &#125;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">reference_wrapper</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> _Reference_wrapper_base&lt;<span class="keyword">typename</span> remove_cv&lt;_Tp&gt;::type&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      _Tp* _M_data;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">typedef</span> _Tp type;</span><br><span class="line">      <span class="built_in">reference_wrapper</span>(_Tp&amp; __indata) <span class="keyword">noexcept</span></span><br><span class="line">      : _M_data(std::__addressof(__indata))</span><br><span class="line">      &#123; &#125;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">      <span class="keyword">operator</span> _Tp&amp;() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">get</span>(); &#125;</span><br><span class="line">      <span class="function">_Tp&amp;</span></span><br><span class="line"><span class="function">      <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> *_M_data; &#125;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们发现<code>ref</code>只是返回了一个模板类<code>reference_wrapper&lt;_Tp&gt;</code>，而这个模板类有点类似引用的底层实现，拥有数据实际存储的指针，<strong>特别值得注意的是</strong>，它实现了对<code>_Tp&amp;</code>的重载，使得它可以转换为引用类型，从而绕过了<code>decay</code>的影响。</p>
<h3 id="另外的办法？">另外的办法？</h3>
<p>既然形参变成左值引用可以，那右值引用是否也可以呢？大概代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue mq;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">(MessageQueue&amp;&amp; mq)</span></span>;</span><br><span class="line"><span class="function">Message <span class="title">consume</span><span class="params">(MessageQueue&amp;&amp; mq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t1 = std::<span class="built_in">thread</span>(produce, mq);</span><br><span class="line">    <span class="keyword">auto</span> t2 = std::<span class="built_in">thread</span>(consume, mq);</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上看起来是比较奇怪的。因为右值引用只能绑定右值，但<code>mq</code>并不是右值，这样不应该能够运行。但是实际上真正运行起来，是会出现编译错，但是原因并不是这个，是因为需要获得一个包含函数指针以及参数列表的<code>std::tuple</code>实例化对象，所以所有参数都应当有拷贝构造或者移动构造，但这里全被<code>delete</code>了。这里仅仅贴一下代码，不进行展开讨论：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Callable, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">     <span class="keyword">static</span> _Invoker&lt;__decayed_tuple&lt;_Callable, _Args...&gt;&gt;</span><br><span class="line">     __make_invoker(_Callable&amp;&amp; __callable, _Args&amp;&amp;... __args)</span><br><span class="line">     &#123;</span><br><span class="line"><span class="keyword">return</span> &#123; __decayed_tuple&lt;_Callable, _Args...&gt;&#123;</span><br><span class="line">    std::forward&lt;_Callable&gt;(__callable), std::forward&lt;_Args&gt;(__args)...</span><br><span class="line">&#125; &#125;;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>对于<code>std::thread</code>的第一个参数，也就是线程运行的函数本身，它的参数一般情况下没有必要使用右值引用。如果参数是原始类型，应当保证拷贝构造函数或者移动构造函数存在（比较常识，但容易忘掉）。如果是左值引用类型，记得对形参加上<code>std::ref</code>即可。</p>
<h2 id="其他的收获">其他的收获</h2>
<p>在形参与实参传递的过程中，T,T&amp;,T&amp;&amp;类型的功能是不同的（注意，此处的T类型仅指<strong>原始类型</strong>）。</p>
<table>
<thead>
<tr>
<th></th>
<th>形参</th>
<th>实参</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>一定会调用构造函数</td>
<td>作为<strong>右值</strong></td>
</tr>
<tr>
<td>T&amp;</td>
<td>绑定左值引用，无构造</td>
<td>作为左值</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>绑定右值引用，无构造</td>
<td>作为<strong>右值</strong></td>
</tr>
</tbody>
</table>
<p>其实与普通的定义语句语义是一样的，但我经常搞混，甚至现在才明白T可以被认为是右值。</p>
<h2 id="参考">参考</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45858169/article/details/114642760">C++：std::thread arguments must be invocable after conversion to rvalues</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangzhicheng1983/article/details/118691854">利用std::is_invocable在编译期间判断函数与传递参数是否匹配</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyxxzjpdez.github.io/newblog/2021/08/28/Problem-about-std-thread/" data-id="cktr5owah0001zzm897i54xg7" data-title="关于std::thread初始化的一点问题" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/multi-thread/" rel="tag">multi-thread</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-template" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/newblog/2021/08/27/template/" class="article-date">
  <time class="dt-published" datetime="2021-08-27T20:47:33.000Z" itemprop="datePublished">2021-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/newblog/2021/08/27/template/">C++模板</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>C++模板类型推导直觉上的结论就是类似宏那样的写出来，然后最后再推导出T的类型。只有在T&amp;&amp;的时候才能将T解释为左值引用或者非引用。两条额外规则。编译器只检查类型兼容（返回值为引用的时候）。</p>
<h2 id="未来待续">未来待续</h2>
<h3 id="以上仅为个人小结。后续看完C-primer-第十六章会再回来更新">以上仅为个人小结。后续看完C++ primer 第十六章会再回来更新</h3>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyxxzjpdez.github.io/newblog/2021/08/27/template/" data-id="cktr5owan0007zzm80flk6rzk" data-title="C++模板" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-new-start" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/newblog/2021/08/27/new-start/" class="article-date">
  <time class="dt-published" datetime="2021-08-27T19:36:02.000Z" itemprop="datePublished">2021-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/newblog/2021/08/27/new-start/">全新的开始</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>不多说，撸起袖子就是干。既然喜欢，就做出点成就来。以前的博客反正也没几篇，丢失就丢失了吧，但是现在开始我需要每周进行记录与更新，也算自我监督，自我勉励吧。目前的打算大概如下：</p>
<ul>
<li>阅读源码。以后端组件为主，类似nginx或者是redis之类的</li>
<li>阅读书籍。目前以c<ins>与多线程编程为主。《C</ins> Primer》与 《C++ Concurrency in Action》等</li>
<li>做点练手项目。目前太生疏，先从实现高效的C++11风格的消息队列开始吧</li>
<li>日常的一些小问题解决过程记录以及一些常识备忘</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyxxzjpdez.github.io/newblog/2021/08/27/new-start/" data-id="cktr5owam0005zzm85lx70t69" data-title="全新的开始" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/newblog/tags/roast/" rel="tag">roast</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/SMP/" rel="tag">SMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/coroutine/" rel="tag">coroutine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/debug/" rel="tag">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/multi-thread/" rel="tag">multi-thread</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/notes/" rel="tag">notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/process/" rel="tag">process</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/roast/" rel="tag">roast</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/shell/" rel="tag">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/newblog/tags/thread/" rel="tag">thread</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/newblog/tags/C/" style="font-size: 15px;">C++</a> <a href="/newblog/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/newblog/tags/SMP/" style="font-size: 10px;">SMP</a> <a href="/newblog/tags/coroutine/" style="font-size: 10px;">coroutine</a> <a href="/newblog/tags/debug/" style="font-size: 10px;">debug</a> <a href="/newblog/tags/multi-thread/" style="font-size: 10px;">multi-thread</a> <a href="/newblog/tags/notes/" style="font-size: 10px;">notes</a> <a href="/newblog/tags/process/" style="font-size: 10px;">process</a> <a href="/newblog/tags/roast/" style="font-size: 15px;">roast</a> <a href="/newblog/tags/shell/" style="font-size: 10px;">shell</a> <a href="/newblog/tags/thread/" style="font-size: 10px;">thread</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/newblog/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/newblog/archives/2021/08/">August 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/newblog/2021/09/19/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/">Linux的进程调度</a>
          </li>
        
          <li>
            <a href="/newblog/2021/09/09/%E5%A4%9A%E6%A0%B8%E7%BC%96%E7%A8%8B/">多核编程</a>
          </li>
        
          <li>
            <a href="/newblog/2021/09/09/gdb%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%8C%87%E4%BB%A4/">gdb常用调试指令</a>
          </li>
        
          <li>
            <a href="/newblog/2021/09/05/%E5%B0%8F%E7%82%B9%E9%9B%86%E9%94%A6/">小点集锦</a>
          </li>
        
          <li>
            <a href="/newblog/2021/08/31/linux-shell-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6/">Linux shell 常用命令集锦</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/newblog/" class="mobile-nav-link">Home</a>
  
    <a href="/newblog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/newblog/js/jquery-3.4.1.min.js"></script>



  
<script src="/newblog/fancybox/jquery.fancybox.min.js"></script>




<script src="/newblog/js/script.js"></script>





  </div>
</body>
</html>