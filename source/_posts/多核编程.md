---
title: 多核编程
date: 2021-09-09 21:22:02
tags:
  - SMP
---

现代计算机体系架构一般都是多核的，但是之前学习操作系统上的时候几乎对此完全没有任何介绍。但是最近在学习《Linux环境编程：从应用到内核》，看kernel源码的时候，发现了CPU变量这个概念，我知道CPU变量是单个CPU上的变量，不被其他CPU变量共享，那么为什么需要有单CPU变量呢？它究竟有什么功能呢？带着这个问题，我花了两天时间，逛了一些博客，大概了解了一些多核编程的问题与解决方案，以下就算是做个小的总结。

## 问题的产生

首先我们需要知道的是现代CPU已经无法单纯靠提高主频来增强性能了，早已进入了多核时代。理论上讲，在依赖关系少的任务下，核心增加可以产生立竿见影的效果。但是大多数任务都必然有资源的共享，最典型的就是内存的共享，这就需要多CPU对内存的修改可见（不可见是很容易产生的，因为实际上CPU并不与内存直接交互，它实际上是直接修改CPU的本地cache，对它的写操作如果没有及时写入内存，那对其他CPU就是不可见的了），而要这个问题就是需要先考虑内存一致性的问题，具体内容参看[一篇博客](https://blog.csdn.net/maokelong95/article/details/80727952)。我们在这里至少需要以下几点：

1. 最理想的内存模型是顺序一致性模型，它可以做到两点：
   * **顺序性：即指令严格地从前往后执行，不做任何的乱序重排。**当然实际上大多数CPU执行都是乱序的，主要有三个方面原因：
     * 编译优化。其实不应该归类在这里，因为我们这边一般考虑CPU执行指令阶段。但是考虑到我们一般写的都是C程序，而不是汇编，所以该问题不应该被忽视。
     * CPU本身的执行优化。为了提升速度，CPU利用自身的性质，将看不出依赖关系的（不同体系架构不一样。为防止出错，我们完全可以认为CPU会胡乱重排。当然，要注意，再胡乱重排至少**保证单CPU上运行一定能保证正确**）指令进行重排提升运行速度。
     * 为了实现一些机制，比如下文会提到的`Store Buffer`以及`Invalid Queue`机制（详见[这篇博客](https://blog.csdn.net/wll1228/article/details/107775976)）而安排的重排。其实可以看做上一点的特例，毕竟这两个机制算是对naive的MESI协议的优化（MESI协议详见这里的[论文](http://www.puppetmastertrading.com/images/hwViewForSwHackers.pdf)与[博客](https://blog.csdn.net/xiaowenmu1/article/details/89705740)）。
   * **原子性：每个指令要么不执行，要么就是一口气执行完，没有中间状态。**在这里需要指出一点误区，我曾经以为一个类似`MOV`那样的指令执行CPU已经保证了它的原子性，但实际上并不是的。只是在单CPU上看不出任何问题，因为任何中断都会在CPU执行完指令（同时如果是乱序执行的，也会保证最后一个指令前的所有指令被执行）以后才会作出相应。因此在单CPU的情况下完全看不出CPU执行一个指令只执行到一半的状态。但是在多核CPU的情况下，问题就完全变了，一个CPU读取一个共享内存的时候完全有可能另一个CPU在对该内存进行写，但还没有完成写入，这时候前一个CPU读取的就是一个非法旧值。实际上这里就从P1（指第一个cpu）先写，然后P2（指第二个cpu）再读变成了：P2先读，P1再写了，也即P2对P1的修改并不可见。其实一般情况下我们无法知道实际上是P1写指令在前，还是P2读指令在前，但是我们应当至少保证一点，那就是任何共享内存的写操作不应当完全并行，而应当立即进行广播告知其他CPU（此时需要对数据总线加锁），从而使得写操作被序列化，使得**可见性**的问题得以解决。
   
2. 顺序一致性模型对硬件要求过高，不能实现很好的性能优化。因此，在实际情况下，我们一般对该模型放松一些条件，因此引入了宽松一致性模型。宽松一致性模型的具体实现完全取决于实际架构，具体情况详见上面博客以及wikipedia的[memory order](https://en.wikipedia.org/wiki/Memory_ordering)词条。我们在这里仅仅讨论x86使用的TSO模型，我们从上面的顺序性与原子性上分别做出约束放宽
   * 顺序性（可以理解为单核上的运行顺序）
     * W -> R **支持重排**
     * W -> W 不支持重排
     * R -> R 不支持重排
     * R -> W 不支持重排
   * 原子性（可以理解为多核之间的内存可见性）
     * **不允许**提前读其他CPU的写，其实就是每个CPU看到其他CPU对**同一个**共享内存的写入的顺序是一致的。如果不理解详见原博客，以及[Intel® 64 Architecture Memory Ordering White Paper](https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf)里提到的`Total order on stores to the same location`。
     * **允许**两个CPU在分别写入两个**不同**的共享变量时不一致。主要是因为`store buffer`的优化导致本地读有效，也就是保证单CPU上运行不会出问题，但是此时远程CPU的那个共享内存还没被标记失效就已经运行完了。如果不理解详见[Intel® 64 Architecture Memory Ordering White Paper](https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf)里提到的`Intra-processor forwarding is allowed`。

3. 我们看到变成宽松一致性模型固然方便优化，但是一般为了编程方便，我们一般都假定其是顺序一致性的，如果不满足的话，就容易出现各种麻烦。所以我们需要架构有机制可以转为顺序一致性模型。以x86的TSO模型为例，其主要有两个机制：

   * read-modify-write（RMW）

     所谓 RMW，也即 intel 64 架构中的 locked 指令。它只有两个功能，一个是保证本身的原子性，也就是保证本身对所有CPU可见；另一个是该指令上下的指令不可被跨越进行重排。早期是直接锁数据总线，后来转变为cache locking，并结合MESI缓存一致性协议进行一致性的维护。

   * membar，也即内存屏障

     博客原文就特意加重`globally visible`这两个单词。它能够保证屏障前的指令对屏障后的指令**全局可见**。所以理论上只要设置对位置，它可以完美地将宽松一致性模型转变为顺序一致性模型。

## 用户空间为什么不需要考虑这些问题

## 回归问题
