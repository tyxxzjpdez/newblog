---
title: Linux的进程调度
date: 2021-09-19 17:49:17
tags:
  - Linux

---

本文对Linux的进程调度做简单的总结，后续会随着理解的加深不断更新。本文的大部分内容基于《用“芯”探核：基于龙芯的Linux内核探索解析》，内核版本也依据书本为v5.4.x。

## 简介

​		调度核心主要负责周期性时钟处理和进程切换，而调度类（目前主要包括实时调度类rt_sched_class，公平调度类fair_sched_class和空闲调度类idle_sched_class）主要负责进程组织和调度策略。其他诸如负载均衡（多处理器系统中用于避免一个处理器过于频繁而另一个处理器过于空闲的机制）、进程迁移等的话题则是调度核心和调度类协同操作的结果。不同的调度类之间具有绝对的优先顺序：实时进程永远优先于普通进程，而普通进程永远优先于空闲进程。

​		本文暂时主要介绍三个调度类，其中重点介绍公平调度类CFS。

## 调度类

### 公平调度类：CFS策略

本质上，完全公平算法就是**希望让每个执行单位获得相同的执行时间**。如果我们将优先级考虑进来，就可以这样描述：

```
我们首先定义调度周期为将所有处于TASK_RUNNING状态的进程都调度一遍的时间，那每个进程实际应当分配的时间片应当满足下面的公式：
                                                   
                                                分配给进程的运行时间 = 调度周期 * 进程权重 / 所有进程权重之和
```

以上的公式是相当符合直觉的，简单来说其实就是每个进程的时间片大小与进程权重成正比。所以一个很简单的实现方式就是，直接按照上面的方式固定时间片让程序运行给定时间然后被抢占。具体实现可以利用时钟定期触发的中断记录当前进程此次调度执行的时间，并在发现累计超过给定时间片的时候将其睡眠，调入其他进程。这确实是一种简单有效的方式，实际上Linux也大概是在此基础上进行优化的。其中比较值得注意的是下面两个问题：

1. **如何设计进程的权重**？如果是等差数列很容易导致优先级较高的两级之间与优先级较低的两级之间差距悬殊。举个例子，不是一般性，假设相邻优先级之间差1，比如现在有几个等待调度的进程的优先级是100，99，3，2。明明第一二的两个进程和第三四的两个进程都各自优先级只相差1，但是加权比例却很悬殊，也就是100/（100+99+3+2）与99/（100+99+3+2）很接近，但是3/（100+99+3+2）与2/（100+99+3+2）虽然绝对差距一致，但是前者相对比后者却多运行了一半时间。这不符合我们希望的优先级的设定，我们希望优先级n+1的进程比优先级n的进程CPU资源仅相差10%，所以我们显然应当设计为等比数列，所以它应当满足下式：

   ``` 
                                                                                                                       1/(1+1*X) = 45%    =>  X = 55/45 = 1.222
   ```

   所以综上我们可以权重使得相邻权重成1.222倍比重，实际Linux大概是在1.24到1.25之间。

2. 如果确定要抢占，那**应当将执行权交给谁呢**？而且就算当前执行的进程还没用尽时间片，就一定不将它切换出去吗，如果**有其他进程距离希望的时间片长度差距更远该怎么办呢**？为了解决以上的问题，内核给每个进程维护了一个vruntime的变量，它是实际运行时间根据优先级权重归一化之后的虚拟运行时间。对于上面的第一个问题，我们直接选择vruntime最小的进程即可（考虑到进程频繁的创建和终止，所以采用红黑树进行维护）。而对于后面的问题，我们设计一个粒度值，如果当前进程的vruntime仅仅比最小的vruntime多出少于该粒度值的大小，那就不需要重新调度，否则就需要调度。

### 实时调度类

为每个优先级维护一个队列。

`SCHED_RR`：实时进程调度策略，时间片轮转，进程用完时间片后加入优先级对应运行队列的尾部，把CPU让给同优先级的其他进程；

`SCHED_FIFO`：实时进程调度策略，先进先出调度没有时间片，没有更高优先级的情况下，只能等待主动让出CPU；

### 空闲调度类

每个CPU都会有一个idle线程，当没有其他进程可以调度时，调度运行idle线程。
