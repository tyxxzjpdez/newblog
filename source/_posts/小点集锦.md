---
title: 小点集锦
date: 2021-09-05 21:10:28
tags:
  - notes
---

主要记录一些有点意思但又没有必要为此写新博客的一些点

1. 迭代器的失效一般与容器类型相关，详见[C++迭代器失效的几种情况总结](https://www.cnblogs.com/fnlingnzb-learner/p/9300073.html)。但是具体实现可能会有区别，例如vector的erase为了减小开销就使用拷贝然后销毁末尾的元素，这样的erase其实并不会让删除元素后面的所有迭代器失效，详见[c++之你真的了解vector的erase吗](https://www.cnblogs.com/chaohacker/p/13024357.html)

2. `gcc`编译链接的时候使用`-v`参数，可以显示具体的详细过程。我们可以发现最后一步并没有直接使用`ld`，而是使用了`collect2`，它主要是为了实现main函数开始前以及结束后的一些函数的注册。详见[collect2](http://www.wanglianghome.org/2011/04/14/collect2/)以及[官方文档](https://gcc.gnu.org/onlinedocs/gccint/Collect2.html)，也可以使用`info gccint-11 'collect2'`查看离线的官方文档。

3. 数据库加间隙锁的本质是因为当本条满足条件，那最多它的相邻的两个区间也会满足条件，当这些所有间隙都被锁了以后，才不会出现幻读，因为要满足之前条件的insert必然在上面的所有间隙内。（当然以上是在查询为索引的情况下）

4. 逻辑上不要认为因为需要epoll的边沿触发所以才将打开文件属性设置为非阻塞。而应当反过来，考虑到IO的复杂性，我们希望在epoll的线程中**为了公平要保持忙碌**，不要陷入某个IO阻塞使得其他IO饥饿，所以我们要设计一个非阻塞的多路复用模型（本质上其实也就是使得事件响应机制**变得更加细粒度化**）。一般非阻塞我们都会读到出现EAGAIN错误为止，而这相当于修改了打开文件的状态。所以我们希望epoll不要对IO的所有状态都返回事件，而应当仅仅在打开文件的状态由不可用到可用才返回事件。也即边沿触发是对多路IO复用的非阻塞版本的额外支持。

5. 可以在构造函数的**初始化列表里强制类成员的初始化顺序**，使得含有依赖的初始化能够顺利完成。

6. 进程上下文与中断上下文的区别

   * 进程上下文：用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。具体可以分为：

     * 用户级上下文: 正文、数据、用户堆栈以及共享存储区；
     * 寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；
     * 系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。

     切换进程上下文需要切换以上所有上下文。但是系统调用会陷入到内核，仅进行寄存器上下文的切换，此时内核代表用户在内核态执行，也就是说**此时陷入内核执行的代码绑定了一个存在用户空间的进程**。

   * 中断上下文：硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。**完全是硬件与内核的交互，无需绑定一个存在用户空间的进程。同时也因为机制简单，无法再被切换出，因此禁止睡眠。**
   
7. spurious wakeup（虚假唤醒）

   主要摘自[知乎邱昊宇的答案](https://www.zhihu.com/question/271521213)

   * 条件变量的等待被其他信号中断，这时候条件压根从来没有满足过，显然需要再次执行自旋
   * 明明有对应的唤醒，但条件不成立。主要是因为有其他线程在本线程重新加锁之前，已经获取锁改变了条件变量，并再释放锁。这时候本线程就需要再次检查条件变量是否满足条件。

   由于上面两个原因，条件变量的等待就需要被循环套住。
   
8. C++中函数返回值一般是右值（除非返回值为左值引用），这样返回的时候如果不被右值引用绑定，就只能调用拷贝构造函数或者赋值函数保留值，这就多了开销。一般正常正确的使用中，如果返回为引用，一般不需要考虑生命周期的问题，因为设计为返回引用，返回值的周期必定比函数长，但如果不拷贝或赋值而是绑定，不保证生命周期意外提前结束（当然如果有智能指针的话，保证拷贝或者赋值语义就行，绝对不要绑定引用）。

9. 记住一点：函数返回和返回后被“接住”是两个过程。

10. c++模板实现类型是否有某成员

    ```c++
    #include <iostream>
    
    template<typename T>
    struct has_no_destroy
    {
      template <typename C> static char test(decltype(&C::no_destroy));
      template <typename C> static int32_t test(...);
      const static bool value = sizeof(test<T>(0)) == 1;
    };
    
    struct A{
        void no_destroy();
    };
    
    int main()
    {
        std::cout<<has_no_destroy<A>::value<<std::endl;
        return 0;
    }
    ```

    *  所有函数只需要有函数声明，不需要有定义，运行时无开销
    * 使用返回值的字节大小来确定实例化了哪个模板（很妙）
    * 参数可以使用decltype灵活指定类型
    * NULL(0)可以隐式地转为函数指针类型

11. To be continued
