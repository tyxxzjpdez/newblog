---
title: 小点集锦
date: 2021-09-05 21:10:28
tags:
  - notes
---

主要记录一些有点意思但又没有必要为此写新博客的一些点

1. 迭代器的失效一般与容器类型相关，详见[C++迭代器失效的几种情况总结](https://www.cnblogs.com/fnlingnzb-learner/p/9300073.html)。但是具体实现可能会有区别，例如vector的erase为了减小开销就使用拷贝然后销毁末尾的元素，这样的erase其实并不会让删除元素后面的所有迭代器失效，详见[c++之你真的了解vector的erase吗](https://www.cnblogs.com/chaohacker/p/13024357.html)

2. `gcc`编译链接的时候使用`-v`参数，可以显示具体的详细过程。我们可以发现最后一步并没有直接使用`ld`，而是使用了`collect2`，它主要是为了实现main函数开始前以及结束后的一些函数的注册。详见[collect2](http://www.wanglianghome.org/2011/04/14/collect2/)以及[官方文档](https://gcc.gnu.org/onlinedocs/gccint/Collect2.html)，也可以使用`info gccint-11 'collect2'`查看离线的官方文档。

3. 数据库加间隙锁的本质是因为当本条满足条件，那最多它的相邻的两个区间也会满足条件，当这些所有间隙都被锁了以后，才不会出现幻读，因为要满足之前条件的insert必然在上面的所有间隙内。（当然以上是在查询为索引的情况下）

4. 逻辑上不要认为因为需要epoll的边沿触发所以才将打开文件属性设置为非阻塞。而应当反过来，考虑到IO的复杂性，我们希望在epoll的线程中**为了公平要保持忙碌**，不要陷入某个IO阻塞使得其他IO饥饿，所以我们要设计一个非阻塞的多路复用模型（本质上其实也就是使得事件响应机制**变得更加细粒度化**）。一般非阻塞我们都会读到出现EAGAIN错误为止，而这相当于修改了打开文件的状态。所以我们希望epoll不要对IO的所有状态都返回事件，而应当仅仅在打开文件的状态由不可用到可用才返回事件。也即边沿触发是对多路IO复用的非阻塞版本的额外支持。

5. 可以在构造函数的**初始化列表里强制类成员的初始化顺序**，使得含有依赖的初始化能够顺利完成。

6. 进程上下文与中断上下文的区别

   * 进程上下文：用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。具体可以分为：

     * 用户级上下文: 正文、数据、用户堆栈以及共享存储区；
     * 寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；
     * 系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。

     切换进程上下文需要切换以上所有上下文。但是系统调用会陷入到内核，仅进行寄存器上下文的切换，此时内核代表用户在内核态执行，也就是说**此时陷入内核执行的代码绑定了一个存在用户空间的进程**。

   * 中断上下文：硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。**完全是硬件与内核的交互，无需绑定一个存在用户空间的进程。同时也因为机制简单，无法再被切换出，因此禁止睡眠。**
